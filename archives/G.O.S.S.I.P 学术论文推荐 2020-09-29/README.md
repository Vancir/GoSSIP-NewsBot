 今天给大家推荐的是来自USENIX Security'20的一篇关于Android固件细粒度访问控制的分析的论文。 

  ![]() 

  Android的访问控制模型基于Linux的访问控制模型实现，包括用户和组的读/写/执行权限，Capability-like (CAP) 系统，SEAndroid。SEAndroid根据user，role，type和level的一组标签制定规则，type是最基础的标识符，策略决定了一个进程可以访问什么样的type和action。 

  

  作者开发了一个细粒度的访问控制分析的框架，从设备中提取Android固件，仿真设备的启动过程，收集文件系统的访问控制信息，构建运行中系统的安全状态，生成攻击图。攻击图提供了逻辑查询的接口，通过指定条件，查询攻击路径，得到潜在的访问控制问题。 

  ![]() ![]() 

  BigMAC实现的关键是攻击图的构建，构建流程如图3所示。 

  

  1. 首先要构建主体图Gs，主体图是所有图的起源。通过反编译sepolicy文件获得所有的规则，从规则中提取主体$S$，并且收集主体S对应的实例文件集F。 

  2. 构建数据流图Gd。关注反编译sepolicy里规则的访问向量，对于有allow read/write访问向量的规则在主体图Gs上添加数据流动的边，形成数据流图Gd。 

  3. 使用实例文件拆分Gd中的文件对象节点获得平坦数据流图Gf。 

  4. 构建进程树Gp。模拟启动过程获得进程树，并且通过如图1中的DAC/MAC配置文件（如图1所示）里指定的进程凭据或者Linux进程语义给进程分配进程凭据。 

  5. 叠加数据流图和进程树生成攻击图。即对于进程树中主体Sj的每个进程Pi，将Gf中主体Sj的所有出入边复制到进程树中的Pi中，以查询允许原始MAC策略读取或写入的具体对象。 

  ![]() 

  作者在Samsung和Pixel的四个版本的Android固件上运行BigMAC，结果可以恢复到高达74.7%的进程凭证，并且对文件系统的DAC和MAC信息恢复的准确性超过98%。 

  ![]() 

  ![]() 

  作者对Samsung S8 +和LG G7固件的评估揭示了多个策略问题，包括LG上的不受信任的应用程序能够与内核监视服务进行通信，Samsung S8+允许从不受信任的应用程序到某些root进程的IPC，至少有24个具有CAP\_SYS\_ADMIN capability的进程。 

  ![]() 

  ![]() 

  ![]() 

  原文链接：https://www.usenix.org/system/files/sec20-hernandez.pdf 

